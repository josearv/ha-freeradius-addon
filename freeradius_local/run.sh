#!/usr/bin/env bash
set -euo pipefail

OPTIONS="/data/options.json"

RDB="/etc/raddb"
PERSIST="/data/raddb"
PERSIST_CERTS="${PERSIST}/certs"
CERTS_DIR="${RDB}/certs"

CLIENTS_CONF="${RDB}/clients.conf"
AUTHORIZE_FILE="${RDB}/mods-config/files/authorize"

# Regenera si el certificado caduca en menos de N días
RENEW_DAYS="${RENEW_DAYS:-14}"
RENEW_SECONDS=$(( RENEW_DAYS * 24 * 60 * 60 ))

mkdir -p "${PERSIST}" "${PERSIST_CERTS}"

enable_mod() {
  local mod="$1"
  if [ -f "${RDB}/mods-available/${mod}" ] && [ ! -e "${RDB}/mods-enabled/${mod}" ]; then
    ln -s "${RDB}/mods-available/${mod}" "${RDB}/mods-enabled/${mod}"
  fi
}

enable_site() {
  local site="$1"
  if [ -f "${RDB}/sites-available/${site}" ] && [ ! -e "${RDB}/sites-enabled/${site}" ]; then
    ln -s "${RDB}/sites-available/${site}" "${RDB}/sites-enabled/${site}"
  fi
}

echo "[FreeRADIUS] Enabling required modules..."
enable_mod "files"
enable_mod "eap"
enable_mod "mschap"

echo "[FreeRADIUS] Enabling required sites..."
enable_site "default"
enable_site "inner-tunnel"

echo "[FreeRADIUS] Generating clients.conf..."
: > "$CLIENTS_CONF"
echo "### Generated by Home Assistant add-on" >> "$CLIENTS_CONF"

# Si no existe .clients, no rompe
jq -c '.clients // [] | .[]' "$OPTIONS" | while read -r c; do
  name="$(echo "$c" | jq -r '.name')"
  ipaddr="$(echo "$c" | jq -r '.ipaddr')"
  secret="$(echo "$c" | jq -r '.secret')"

  cat >> "$CLIENTS_CONF" <<EOF

client ${name} {
  ipaddr = ${ipaddr}
  secret = ${secret}
}
EOF
done

echo "[FreeRADIUS] Generating users file (authorize)..."
mkdir -p "$(dirname "$AUTHORIZE_FILE")"
: > "$AUTHORIZE_FILE"
echo "### Generated by Home Assistant add-on" >> "$AUTHORIZE_FILE"
echo "" >> "$AUTHORIZE_FILE"

# Genera entradas con VLAN si viene 'vlan' (int)
# - Si vlan existe -> añade Tunnel-Type/Medium/Private-Group-Id
# - Si vlan no existe -> solo password (sin VLAN dinámica)
jq -r '
  (.users // [])[] |
  {
    u: (.username // ""),
    p: (.password // ""),
    v: (.vlan // empty)
  } |
  select(.u != "" and .p != "") |
  if (.v | tostring | length) > 0 then
    "\(.u) Cleartext-Password := \"\(.p)\"\n\tTunnel-Type = VLAN,\n\tTunnel-Medium-Type = IEEE-802,\n\tTunnel-Private-Group-Id = \"\(.v)\"\n"
  else
    "\(.u) Cleartext-Password := \"\(.p)\"\n"
  end
' "$OPTIONS" >> "$AUTHORIZE_FILE"

mkdir -p "${CERTS_DIR}"

restore_persisted_certs() {
  if [ -f "${PERSIST_CERTS}/server.pem" ] && [ -f "${PERSIST_CERTS}/server.key" ]; then
    echo "[FreeRADIUS] Restoring persisted certs from /data..."
    cp -a "${PERSIST_CERTS}/." "${CERTS_DIR}/"
  fi
}

cert_is_valid_long_enough() {
  # Devuelve 0 si el cert existe y NO caduca en los próximos RENEW_SECONDS
  local cert="${CERTS_DIR}/server.pem"
  if [ ! -f "$cert" ]; then
    return 1
  fi
  # openssl x509 -checkend devuelve 0 si el cert es válido al menos X segundos
  openssl x509 -in "$cert" -noout -checkend "${RENEW_SECONDS}" >/dev/null 2>&1
}

generate_certs() {
  echo "[FreeRADIUS] Generating EAP certificates (one-time or renewal)..."
  cd "${CERTS_DIR}"

  if [ -x "./bootstrap" ]; then
    ./bootstrap
  elif command -v make >/dev/null 2>&1 && [ -f "Makefile" ]; then
    make
  else
    echo "[FreeRADIUS] ERROR: No bootstrap/Makefile found in ${CERTS_DIR} to generate certs"
    exit 1
  fi

  echo "[FreeRADIUS] Persisting certs to /data..."
  mkdir -p "${PERSIST_CERTS}"
  cp -a "${CERTS_DIR}/." "${PERSIST_CERTS}/"
}

echo "[FreeRADIUS] Ensuring EAP certificates exist..."
restore_persisted_certs

if cert_is_valid_long_enough; then
  echo "[FreeRADIUS] EAP cert OK (not expiring within ${RENEW_DAYS} days)."
else
  echo "[FreeRADIUS] EAP cert missing or expiring soon (< ${RENEW_DAYS} days) -> regenerating."
  generate_certs
fi

echo "[FreeRADIUS] Starting radiusd..."
exec /usr/sbin/radiusd -X
